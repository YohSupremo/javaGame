import greenfoot.*;

public class Person extends Actor
{
    // Animation variables
    private GreenfootImage[] idleFrames;
    private GreenfootImage[] runFrames;
    private GreenfootImage[] jumpFrames;
    private int frameIndex = 0;
    private int delayCounter = 0;
    private int animationDelay = 5;
    private boolean facingRight = true;
    private boolean isRunning = false;
    
    // Physics variables
    private boolean onGround = false;
    private int jumpStrength = -15;
    private int gravity = 1;
    private int vSpeed = 0;
    private int moveSpeed = 3;
    private int airSpeed = 2;
    
    // Platform tracking for moving platforms
    private Platform lastPlatform = null;
    private int lastPlatformX = 0;
    private int lastPlatformY = 0;
    
    public Person() {
        // Load IDLE frames (idle (1).png to idle (12).png)
        idleFrames = new GreenfootImage[12];
        for (int i = 0; i < idleFrames.length; i++) {
            String filename = "idle (" + (i + 1) + ").png";
            idleFrames[i] = new GreenfootImage(filename);
        }
        // Load RUN frames (run (1).png to run (8).png)
        runFrames = new GreenfootImage[8];
        for (int i = 0; i < runFrames.length; i++) {
            String filename = "run (" + (i + 1) + ").png";
            runFrames[i] = new GreenfootImage(filename);
        }
        // Load JUMP frames (jump (1).png to jump (4).png)
        jumpFrames = new GreenfootImage[4];
        for (int i = 0; i < jumpFrames.length; i++) {
            String filename = "jump (" + (i + 1) + ").png";
            jumpFrames[i] = new GreenfootImage(filename);
        }
        setImage(idleFrames[0]); // Start idle
    }
    
    public void act()
    {
        checkPlatformPush();
        handleMovement();
        correctPlatformPenetration(); // Correct after horizontal movement
        ensureFullyOutsidePlatforms(); // Check BEFORE gravity to catch corner penetration
        applyGravity();
        checkSpikesAndTraps();
        checkFallOff();
        nextLevel();
        animate();
    }
    
    // NEW METHOD: Ensures player is fully outside all platforms (prevents corner penetration)
    private void ensureFullyOutsidePlatforms()
    {
        // Only run this check when in the air to prevent corner penetration during jumps
        // Don't run when on ground to avoid bouncing
        if (onGround)
        {
            return;
        }
        
        java.util.List<Platform> platforms = getIntersectingObjects(Platform.class);
        
        for (Platform platform : platforms)
        {
            if (pixelPerfectCollision(platform.getImage(), platform))
            {
                // Calculate boundaries
                int personLeft = getX() - getImage().getWidth() / 2;
                int personRight = getX() + getImage().getWidth() / 2;
                int personTop = getY() - getImage().getHeight() / 2;
                int personBottom = getY() + getImage().getHeight() / 2;
                
                int platformLeft = platform.getX() - platform.getImage().getWidth() / 2;
                int platformRight = platform.getX() + platform.getImage().getWidth() / 2;
                int platformTop = platform.getY() - platform.getImage().getHeight() / 2;
                int platformBottom = platform.getY() + platform.getImage().getHeight() / 2;
                
                // Calculate penetration depths
                int penetrationLeft = personRight - platformLeft;
                int penetrationRight = platformRight - personLeft;
                int penetrationTop = personBottom - platformTop;
                int penetrationBottom = platformBottom - personTop;
                
                // Find smallest penetration to determine best push direction
                int minPenetration = Math.min(Math.min(penetrationLeft, penetrationRight),
                                             Math.min(penetrationTop, penetrationBottom));
                
                // Only correct if penetration is significant (more than 3 pixels)
                if (minPenetration <= 3)
                {
                    continue;
                }
                
                // Push out in the direction of smallest penetration
                if (minPenetration == penetrationLeft && penetrationLeft > 0)
                {
                    // Push left
                    setLocation(platformLeft - getImage().getWidth() / 2, getY());
                }
                else if (minPenetration == penetrationRight && penetrationRight > 0)
                {
                    // Push right
                    setLocation(platformRight + getImage().getWidth() / 2, getY());
                }
                else if (minPenetration == penetrationTop && penetrationTop > 0)
                {
                    // Push up
                    setLocation(getX(), platformTop - getImage().getHeight() / 2);
                }
                else if (minPenetration == penetrationBottom && penetrationBottom > 0)
                {
                    // Push down (hit ceiling)
                    setLocation(getX(), platformBottom + getImage().getHeight() / 2);
                    vSpeed = 0;
                }
            }
        }
    }
    
    // Corrects position if player has penetrated into a platform
    private void correctPlatformPenetration()
    {
        // Only run this if we're moving horizontally AND on the ground
        if (!isRunning || !onGround) return;
        
        java.util.List<Platform> platforms = getIntersectingObjects(Platform.class);
        
        for (Platform platform : platforms)
        {
            if (pixelPerfectCollisionForMovement(platform.getImage(), platform))
            {
                // Calculate boundaries
                int personLeft = getX() - getImage().getWidth() / 2;
                int personRight = getX() + getImage().getWidth() / 2;
                
                int platformLeft = platform.getX() - platform.getImage().getWidth() / 2;
                int platformRight = platform.getX() + platform.getImage().getWidth() / 2;
                
                // Calculate horizontal penetration
                int penetrationLeft = personRight - platformLeft;
                int penetrationRight = platformRight - personLeft;
                
                // Push out horizontally based on which side we're closer to
                if (penetrationLeft < penetrationRight && penetrationLeft > 0)
                {
                    // Push left (hit right side of wall)
                    setLocation(platformLeft - getImage().getWidth() / 2, getY());
                }
                else if (penetrationRight > 0)
                {
                    // Push right (hit left side of wall)
                    setLocation(platformRight + getImage().getWidth() / 2, getY());
                }
            }
        }
    }
    
    private void checkPlatformPush()
    {
        Platform currentPlatform = (Platform) getOneIntersectingObject(Platform.class);
        
        if (currentPlatform != null && onGround)
        {
            // If we're on a platform, check if it moved
            if (lastPlatform == currentPlatform)
            {
                int deltaX = currentPlatform.getX() - lastPlatformX;
                int deltaY = currentPlatform.getY() - lastPlatformY;
                
                // Push the person by the platform's movement
                if (deltaX != 0 || deltaY != 0)
                {
                    setLocation(getX() + deltaX, getY() + deltaY);
                }
            }
            
            // Update last platform position
            lastPlatform = currentPlatform;
            lastPlatformX = currentPlatform.getX();
            lastPlatformY = currentPlatform.getY();
        }
        else
        {
            // Not on a platform anymore
            lastPlatform = null;
        }
    }
    
   private void handleMovement() {
    isRunning = false;
    int speed = onGround ? moveSpeed : airSpeed;

    // If world is mediumLevel1 → reverse controls
    if (getWorld() instanceof mediumLevel1 || 
    getWorld() instanceof mediumLevel5 || getWorld() instanceof ohardLevel3) {
        // REVERSED CONTROLS
        if (Greenfoot.isKeyDown("a")) { // A goes RIGHT
            facingRight = true;
            isRunning = true;
            setLocation(getX() + speed, getY());
        }
        else if (Greenfoot.isKeyDown("d")) { // D goes LEFT
            facingRight = false;
            isRunning = true;
            setLocation(getX() - speed, getY());
        }
    } 
    // Else → normal controls (easyLevel worlds)
    else {
        // NORMAL CONTROLS
        if (Greenfoot.isKeyDown("a")) { // Left
            facingRight = false;
            isRunning = true;
            setLocation(getX() - speed, getY());
        }
        else if (Greenfoot.isKeyDown("d")) { // Right
            facingRight = true;
            isRunning = true;
            setLocation(getX() + speed, getY());
        }
    }

    // Jump stays the same
    if ((Greenfoot.isKeyDown("space") || Greenfoot.isKeyDown("w")) && onGround) {
        jump();
    }
}

    
    // Check if the character can move to a specific position
    private boolean canMoveTo(int x, int y) {
        int originalX = getX();
        int originalY = getY();
        
        setLocation(x, y);
        boolean canMove = !isTouchingPlatformForHorizontalMovement();
        setLocation(originalX, originalY);
        
        return canMove;
    }
    
    // Special collision check for horizontal movement (only checks bottom part of character)
    private boolean isTouchingPlatformForHorizontalMovement() {
        java.util.List<Platform> platforms = getIntersectingObjects(Platform.class);
        if (!platforms.isEmpty()) {
            for (Platform platform : platforms) {
                if (pixelPerfectCollisionForMovement(platform.getImage(), platform)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    // Pixel-perfect collision detection for horizontal movement (only checks bottom 1/3 of character)
    private boolean pixelPerfectCollisionForMovement(GreenfootImage otherImg, Actor other) {
        GreenfootImage personImg = getImage();
        
        int dx = getX() - other.getX();
        int dy = getY() - other.getY();
        
        int personW = personImg.getWidth();
        int personH = personImg.getHeight();
        int otherW = otherImg.getWidth();
        int otherH = otherImg.getHeight();
        
        // Only check the bottom 1/3 of the character for horizontal movement
        int startY = personH * 2 / 3;
        
        for (int x = 0; x < personW; x++) {
            for (int y = startY; y < personH; y++) {
                int otherX = x - personW / 2 - dx + otherW / 2;
                int otherY = y - personH / 2 - dy + otherH / 2;
                
                if (otherX >= 0 && otherX < otherW && otherY >= 0 && otherY < otherH) {
                    if (personImg.getColorAt(x, y).getAlpha() > 0 &&
                        otherImg.getColorAt(otherX, otherY).getAlpha() > 0) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    private void jump()
    {
        vSpeed = jumpStrength;
        onGround = false;
    }
    
    private void applyGravity()
    {
        // Apply gravity
        if (vSpeed < 9)
        {
            vSpeed = vSpeed + gravity;
        }
        
        // Move vertically pixel by pixel to prevent penetration
        int steps = Math.abs(vSpeed);
        int sign = vSpeed > 0 ? 1 : -1;
        
        for (int i = 0; i < steps; i++)
        {
            setLocation(getX(), getY() + sign);
            
            // Check for collision after each pixel movement
            if (isTouchingPlatform())
            {
                // Move back one pixel
                setLocation(getX(), getY() - sign);
                
                if (vSpeed > 0) // Was falling down
                {
                    onGround = true;
                    vSpeed = 0;
                }
                else // Was moving up (hit ceiling)
                {
                    vSpeed = 0;
                }
                return;
            }
        }
        
        // If we didn't hit anything, we're in the air
        onGround = false;
    }
    
    // Check if touching platform with precise collision detection
    private boolean isTouchingPlatform()
    {
        java.util.List<Platform> platforms = getIntersectingObjects(Platform.class);
        if (!platforms.isEmpty())
        {
            for (Platform platform : platforms)
            {
                if (pixelPerfectCollision(platform.getImage(), platform))
                {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    // Full pixel-perfect collision detection
    private boolean pixelPerfectCollision(GreenfootImage otherImg, Actor other)
    {
        GreenfootImage personImg = getImage();
        
        int dx = getX() - other.getX();
        int dy = getY() - other.getY();
        
        int personW = personImg.getWidth();
        int personH = personImg.getHeight();
        int otherW = otherImg.getWidth();
        int otherH = otherImg.getHeight();
        
        for (int x = 0; x < personW; x++)
        {
            for (int y = 0; y < personH; y++)
            {
                int otherX = x - personW / 2 - dx + otherW / 2;
                int otherY = y - personH / 2 - dy + otherH / 2;
                
                if (otherX >= 0 && otherX < otherW && otherY >= 0 && otherY < otherH)
                {
                    if (personImg.getColorAt(x, y).getAlpha() > 0 &&
                        otherImg.getColorAt(otherX, otherY).getAlpha() > 0)
                    {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    private void checkSpikesAndTraps()
    {
        java.util.List<Spike> spikes = getIntersectingObjects(Spike.class);
        
        for (Spike spike : spikes)
        {
            GreenfootImage spikeImg = spike.getImage();
            GreenfootImage personImg = getImage();
            int dx = getX() - spike.getX();
            int dy = getY() - spike.getY();
            
            for (int x = 0; x < personImg.getWidth(); x++)
            {
                for (int y = 0; y < personImg.getHeight(); y++)
                {
                    int spikeX = x - personImg.getWidth() / 2 - dx + spikeImg.getWidth() / 2;
                    int spikeY = y - personImg.getHeight() / 2 - dy + spikeImg.getHeight() / 2;
                    
                    if (spikeX >= 0 && spikeX < spikeImg.getWidth() &&
                        spikeY >= 0 && spikeY < spikeImg.getHeight())
                    {
                        if (personImg.getColorAt(x, y).getAlpha() > 0 &&
                            spikeImg.getColorAt(spikeX, spikeY).getAlpha() > 0)
                        {
                            Greenfoot.setWorld(new easyLevel1());
                            return;
                        }
                    }
                }
            }
        }
    }
    
    private void checkFallOff()
    {
        if (getY() >= 399)
        {
            Greenfoot.setWorld(new easyLevel1());
        }
    }
    
    public void nextLevel()
    {
        if (getX() >= 740)
        {
            Greenfoot.setWorld(new easyLevel1());
        }
    }
    
    private void animate() {
        delayCounter++;
        if (delayCounter >= animationDelay) {
            delayCounter = 0;
            frameIndex++;
            
            GreenfootImage[] currentFrames;
            
            if (!onGround) {
                currentFrames = jumpFrames;
            } else if (isRunning) {
                currentFrames = runFrames;
            } else {
                currentFrames = idleFrames;
            }
            
            if (frameIndex >= currentFrames.length) {
                frameIndex = 0;
            }
            
            GreenfootImage img = new GreenfootImage(currentFrames[frameIndex]);
            if (!facingRight) {
                img.mirrorHorizontally();
            }
            setImage(img);
        }
    }
}